# XAtlas Swift Binding
This is a Swift package that provides a binding for the [XAtlas](https://github.com/jpcy/xatlas), which is a fast and lightweight chart generation library for UV-mapping 3D models. This package enables Swift developers to use XAtlas in their projects without having to write C code.

#Installation
To use this package in your project, you can add the following line to the dependencies section of your Package.swift file:
```swift
.package(url: "https://github.com/tatsuya-ogawa/SwiftXAtlas.git", from: "1.0.0")
```
# Usage
First, you need to create an instance of the XAtlas class:
```swift
let xatlas = XAtlas()
```

Then, you can generate charts for your 3D models by passing an array of objects that conform to the XAtlasArgument protocol to the generate method of the XAtlas instance:
```swift
xatlas.generate([XAtlasArgument(points: points, indices: faces)])
```
In the above example, points is an array of simd_float3 representing the vertices of the 3D model, and faces is an array of Int representing the indices of the faces of the 3D model.

Once the charts are generated, you can access the resulting meshes and their mappings by calling the mesh method of the XAtlas instance:
```swift
let mesh = xatlas.mesh(at: 0)
```
In the above example, we are accessing the first mesh that was generated by XAtlas.

Finally, you can use the resulting meshes and mappings in your rendering pipeline. For example, you can use the indices and vertices of the mesh to render the 3D model, and you can use the UV mappings to apply textures to the model.

# Example
Here is an example usage of this package:
```swift
import XAtlas

let points: [simd_float3] = /* vertices of the 3D model */
let faces: [Int] = /* indices of the faces of the 3D model */

let xatlas = XAtlas()
xatlas.generate([XAtlasArgument(points: points, indices: faces)])

let mesh = xatlas.mesh(at: 0)
print("Number of indices: \(mesh!.indices.count)")
print("Number of mappings: \(mesh!.mappings.count)")
```

Here's an example of how to create a struct conforming to the XAtlasArgument protocol:
```swift
struct ExampleArgument: XAtlasArgument {
    var points: [Point]
    var indices: [UInt32]
    
    func indexFormat() -> IndexFormat {
        return IndexFormat.uint32
    }
    
    func vertexCount() -> UInt32 {
        return UInt32(points.count)
    }
    
    func vertexPositionData() -> UnsafeRawPointer {
        return UnsafeRawPointer(points)
    }
    
    func vertexPositionStride() -> UInt32 {
        return UInt32(MemoryLayout<Point>.stride)
    }
    
    func vertexNormalData() -> UnsafeRawPointer {
        return UnsafeRawPointer(points).advanced(by: MemoryLayout<SIMD3<Float>>.stride)
    }
    
    func vertexNormalStride() -> UInt32 {
        return UInt32(MemoryLayout<Point>.stride)
    }
    
    func indexCount() -> UInt32 {
        return UInt32(indices.count)
    }
    
    func indexData() -> UnsafePointer<UInt32> {
        return UnsafePointer(indices)
    }
    
    init(points: [Point], indices: [UInt32]) {
        self.points = points
        self.indices = indices
    }
}
```
In this example, Point is a type representing the vertex data of your 3D model, and indices is an array of UInt32 representing the indices of the faces of the 3D model.

You need to implement the methods of the XAtlasArgument protocol to provide the necessary data to XAtlas for chart generation. The vertexPositionData and vertexNormalData methods return pointers to the vertex data (in this case, Point), and the vertexPositionStride and vertexNormalStride methods return the stride of the vertex data in bytes. The indexData method returns a pointer to the index data, and the indexCount method returns the number of indices.

Finally, you can create an instance of your ExampleArgument struct and pass it to the generate method of the XAtlas instance:
```swift
let exampleArgument = ExampleArgument(points: /* array of points */, indices: /* array of indices */)
xatlas.generate([exampleArgument])
```
